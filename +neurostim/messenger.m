classdef messenger < handle
    % Class to handle communication between the local computer that runs
    % the experiment and a remote computer.
    % In the simplest, default form, the remote computer passively receives
    % the messages that are generated by writeToFeed commands issued by stimuli and plugins.
    % These are messages that are intended for the experimenter and are
    % written to the command line.
    %
    % To avoid interfering witht the experiment itself, these messages can
    % be cached and written out in the intertrial interval (localCache =
    % true), and they can also be sent to a different computer by
    % specifying host name and starting a messenger there.
    %
    % This makes it possible to run the experiment on a single
    % monitor machine (which improves timing of PTB) and still get
    % online information on the progression of the experiment.
    %
    % Usage:
    % If I want to receive messages on a remote computer called
    % 'moustache.vision.rutgers.edu' I add this to the experiment file:
    %
    % c.messenger.host = 'moustache.vision.rutgers.edu'
    %
    % And, on moustache.vision.rutgers.edu, I start Matlab and then run
    % neurostim.messenger(true);
    %  This will start a local "server" that gets its messages from the
    %  Neurostim application ("client").
    %
    % Messenger can also do two-way communication, which is useful to
    % generate closed-loop experiments. In that case the remote computer
    % could be running some data analysis and send back updates to the
    % parameters of the experiment. For this, the remote class defines a
    % .remoteFunction that returns cmd structs which are used to set
    % variables on the Neurostim side:
    % data.command = 'SETSTICKY'
    % data.gabor.orientation = 0; % Set the .orientation property of the
    % .gabor stimulus to 0  (the SET data.command would set the value once, to
    % be overwritten by the default (or the condition specific value) on
    % the next trial.
    %
    % BK March 2019.
    
    properties (Constant)
        EMPTYCACHE = struct('command',repmat({'CACHE'},[1000 1]),'style',cell(1000,1),'formatSpecs',cell(1000,1),'msg',cell(1000,1),'plg',cell(1000,1),'trialTime',cell(1000,1),'trial',cell(1000,1));
    end
    
    properties (SetAccess=public, GetAccess=public)
        %% Properties of the remote server and local client
        host=''; % The remote server to connect to  (empty means no remote server)
        port=1024;
        timerPeriod= 2; % the remote host will check for new inputs every 2 seconds.
        autoRestart = true; % TCP connections are closed at the end of an experiment, but with this set to true, the remote will automatically start waiting for the next experiment.
        
        outputBufferSize= 100000; % bytes
        inputBufferSize= 100000; % bytes
        timeout = 1; % seconds
        
        
        %% Cache
        localCache= false;    % Write out only after the trial ends [false]
        cache = neurostim.messenger.EMPTYCACHE;  % initialize empty
        cacheCntr=0;
        echo= true;            % Even when logging remotely, generate local echo too.
        
        useColor= true;        % Use cprintf's color functionality
        
        cic; % Handle to the parent cic
        remoteFunction; % Handle to a function that does extra processing on the remote host.
        verbose = false; % More output,for debuggin
        
    end
    properties (SetAccess=private, GetAccess=public)
        isRemote= false;
        tcp; % Leave this untyped so that someone without the TCPIP toolbox can use the object locally.
    end
    
    properties (Dependent)
        hasRemote;
    end
    
    methods
        function v=get.hasRemote(o)
            v = ~isempty(o.host);
        end
    end
    
    
    methods
        function o= messenger(remote)
            % Create a messenger. If the optional input is set to true,
            % a remote messenger will be setup and this will start running
            % updates on the default timer.
            o = o@handle;
            if nargin<1
                remote =false;
            end
            if remote
                setupRemote(o);
            end
        end
        
        function close(o)
            if o.hasRemote
                data.command = 'CLOSE';
                sendCommand(o,data);
            end
            printCache(o)
        end
        
        function disp(o)
            if o.isRemote
                disp(['Remote Messenger for ' o.tcp.RemoteHost]);
            elseif o.hasRemote
                disp(['Local messenger connected to ' o.host]);
            else
                disp('Local messenger');
            end
        end
        
        function feed(o,inTrial,style,thisTrial,thisTrialTime,msg,plg)
            % This function is called from plugin.writeToFeed
            if inTrial && (o.localCache || o.hasRemote)
                % Cache the info for later printing to the command line.
                % When using a remote host, feeds must be cached.
                o.cacheCntr= o.cacheCntr+1;
                o.cache(o.cacheCntr).style = style;
                o.cache(o.cacheCntr).inTrial = inTrial;
                o.cache(o.cacheCntr).msg = msg;
                o.cache(o.cacheCntr).plg= plg;
                o.cache(o.cacheCntr).trialTime = thisTrialTime;
                o.cache(o.cacheCntr).trial = thisTrial;
            else
                % Print immediately to the local command line
                print(o,inTrial,style,thisTrial,thisTrialTime,msg,plg);
            end
        end
        
        function sendCommand(o,cmnd)
            if o.hasRemote
                % Send this update struct array to the other side.
                % The struct should have a .command field that specifies
                % the meaning of the command for all elements of the array.
                % data.command = 'SET'
                % data.gabor.orientation = 0 (to set the gabor
                % plugin's orientation parameter)
                data = getByteStreamFromArray(cmnd);
                binblockwrite(o.tcp,[double('#') 1 numel(data) data],'uint8');
            end
            
        end
        
        function afterTrial(o)
            % Called from cic.afterTrial (because messenger is not a plugin)
            % This only runs on the local side.
            if o.hasRemote
                % Send cache of writeToFeed to remote messenger
                sendCommand(o,o.cache(1:o.cacheCntr));
            end
            printCache(o);
        end
        
        
        function printCache(o)
            if o.echo
                % Write out the cache (on either local or remote side)
                [~,ix] = sortrows([[o.cache.trial]' [o.cache.trialTime]']);
                for i=ix'
                    print(o,o.cache(i).inTrial,o.cache(i).style,o.cache(i).trial,o.cache(i).trialTime,o.cache(i).msg,o.cache(i).plg);
                end
                o.cache =neurostim.messenger.EMPTYCACHE;
                o.cacheCntr =0;
            end
        end
        
        
        function setupRemote(o)
            % Start a server on the remote to receive messages from the local client.
            o.checkToolbox;
            o.isRemote = true;
            o.port = 1024;
            o.host = '0.0.0.0';
            [~,serverName] =system('hostname');
            serverName = deblank(serverName);
            o.tcp = tcpip(o.host,o.port,'NetworkRole','Server',...
                'Name',['NS@' serverName],...
                'OutputBufferSize',o.outputBufferSize,...
                'InputBufferSize',o.inputBufferSize,...
                'Terminator','LF',...
                'Timeout',o.timeout);
            o.tcp.BytesAvailableFcn = @o.updateRemote;
            o.tcp.BytesAvailableFcnMode = 'terminator';
            o.tcp.ReadAsyncMode=  'continuous';
            startRemote(o);
        end
        
        function stopRemote(o) %#ok<MANU>
            tmr = timerfind('Name','Messenger');
            if ~isempty(tmr)
                stop(tmr);
                delete(tmr);
            end
        end
        
        function startRemote(o)
            stopRemote(o);
            if strcmpi(o.host,'0.0.0.0')
                hstStr = 'any host';
            else
                hstStr = o.host;
            end
            disp(['Waiting for a messenger connection on port ' num2str(o.port) ' from ' hstStr ' (Press Ctrl-C to terminate)']);
            fopen(o.tcp); % Busy wait until the client connects
            if strcmpi(o.tcp.Status,'Open')
                disp(['Connected to ' o.tcp.RemoteHost]);
            end
            disp('Starting timer to read incoming feeds')
            tmr = timer('BusyMode','drop','ExecutionMode','FixedRate','Period',o.timerPeriod,'TimerFcn',@o.updateRemote,'Name','Messenger');
            start(tmr);
            disp(['Timer running every '  num2str(o.timerPeriod) 's. <a href="matlab:delete(timerfind(''Name'',''Messenger''))">Stop running.</a>']);
        end
        
        % The timer running on the remote host calls this to process the incoming
        % data.
        function updateRemote(o,tmr,event) %#ok<INUSD>
            if ~o.isRemote; return;end
            while o.tcp.BytesAvailable >0
                bytes = binblockread(o.tcp,'uint8'); % Retrieve bytestream encoded message
                data= getArrayFromByteStream(uint8(bytes(4:end))); % Conver to Matlab vars.
                if iscell(data)
                    % This was a call from the client sending a single print line (see o.print)
                    % This is not recommended - too much reading/writing.
                    print(o,data{:});
                elseif isstruct(data)
                    switch upper(data(1).command)
                        case 'CACHE'
                            o.cache =data; % Store it on the host
                            printCache(o); % Print it to the command line
                        case 'CLOSE'
                            disp('Received CLOSE message from experiment');
                            fclose(o.tcp);
                            if o.autoRestart
                                startRemote(o); % Will stop the timer, then wait for a new connection
                            else
                                stopRemote(o); % Stops the timer.
                            end
                    end
                else
                    disp('Received unknown data object from the experiment computer')
                    data %#ok<NOPRT>
                end
            end
            
            %%
            % Extra user-defined processing on the remote side.
            if ~isempty(o.remoteFunction)
                update = o.remoteFunction; % Call the function the user provided with the (remote) messenger object
                if isstruct(update)
                    % If this is a command then send it to the local side.
                    sendCommand(o,update);
                end
            end
            
        end
        
        
        function updateLocal(o)
            % Communication from the remote to the experiment computer.
            % Should only be run by the experiment computer (as it requires
            % access to CIC, which only the client has)
            % Typically added to afterTrial with cic.addScript
            if o.isRemote; return;end
            if ~o.hasRemote; error('To use updateLocal you have to specify a remote host');end
            if o.tcp.BytesAvailable >0
                bytes = binblockread(o.tcp,'uint8'); % Retrieve bytestream encoded message
                data= getArrayFromByteStream(uint8(bytes(4:end))); % Conver to Matlab vars.
                if isstruct(data) && isfield(data(1),'command') && ismember(data(1).command,{'SET','SETSTICKY'})
                    % This should be plugin.property=value (e.g.
                    % data.gabor.contrast = 0.5  will set the gabor plugins
                    % contrast to 0.5
                    pluginNames =fieldnames(data);
                    pluginNames = setdiff(pluginNames,{'command'});
                    for i=1:numel(pluginNames)
                        propertyNames= fieldnames(data.(pluginNames{i}));
                        for j=1:numel(propertyNames)
                            if strcmpi(data(1).command,'SETSTICKY')
                                makeSticky(o.cic.(pluginNames{i}),propertyNames{j});
                            end
                            o.cic.(pluginNames{i}).(propertyNames{j}) = data.(pluginNames{i}).(propertyNames{j});
                            if o.verbose
                                fprintf('[Messenger] %s.%s = %f',pluginNames{i},propertyNames{j},data.(pluginNames{i}).(propertyNames{j}));
                            end
                        end
                    end
                else
                    disp('Received unknown data object from remote computer')
                    data %#ok<NOPRT>
                end
            end
        end
        
        
        
        function setupLocal(o,c)
            % If a host has been specified, this function will try to
            % connect to it. (The Matlab instance running the experiment is
            % the "client").
            % Unlike the remote end, this does not setup a timer. If
            % updateLocal is to be called, it can be added to a beforeTrial
            % or afterTrial update with c.addScript in the experiment file.
            o.cic=c;
            if ~isempty(o.host)
                o.checkToolbox;
                [~,clientName] =system('hostname');
                clientName = deblank(clientName);
                o.tcp = tcpip(o.host,o.port,'NetworkRole','client',...
                    'name',['NS@' clientName],...
                    'OutputBufferSize',o.outputBufferSize,...
                    'InputBufferSize',o.inputBufferSize,...
                    'Terminator','LF',...
                    'Timeout',0.1,...
                    'ByteOrder','littleEndian');
                
                % Check whether the remote is already waiting with a
                % short timeout.
                try
                    fopen(o.tcp); % Busy wait until timeout .
                catch
                    
                end
                o.tcp.Timeout = o.timeout;
                if strcmpi(o.tcp.Status,'Open')
                    disp(['Connected to ' o.tcp.RemoteHost ':' num2str(o.tcp.RemotePort)]);
                else
                    % Not open, ask for confirmation, then try again
                    answer = input(['Is the remote messenger running on ' o.host ':' num2str(o.port) ' ( Use: neurostim.messenger(true);) [Y/n]'],'s');
                    if isempty(answer)
                        answer = 'Y';
                    end
                    connected=false;
                    if strcmpi(answer,'Y')
                        try
                            fopen(o.tcp); % Busy wait until connected.
                        catch
                            
                        end
                        if strcmpi(o.tcp.Status,'Open')
                            connected =true;
                            disp(['Connected to ' o.tcp.RemoteHost ':' num2str(o.tcp.RemotePort)]);
                        else
                            disp(['Failed to connect to the messenger app (' o.host ':' num2str(o.port) '). Is it running? ']);
                        end
                    end
                    if ~connected
                        answer = input('Continue without remote messenger? (Y/n)','s');
                        if strcmpi(answer,'N')
                            error('No remote messenger');
                        else
                            o.host = ''; % No remote host
                        end
                    end
                end
            end
        end
        
        
        function print(o,inTrial,style,thisTrial,thisTrialTime,msg,plg)
            % Prints one or more lines of information to the command line            .
            if inTrial
                phaseStr = '';
            else
                phaseStr = '(ITI)';
            end
            if ~o.useColor
                style = 'NOSTYLE';
            end
            if iscell(msg)
                % multi line message
                maxChars = max(cellfun(@numel,msg));
                neurostim.utils.cprintf(style,'TR: %d: (T: %.0f %s) %s \n',thisTrial,thisTrialTime,phaseStr,plg);
                neurostim.utils.cprintf(style,'\t%s\n',repmat('-',[1 maxChars]));
                for i=1:numel(msg)
                    neurostim.utils.cprintf(style,'\t %s\n',msg{i}); % These are the message lines
                end
                neurostim.utils.cprintf(style,'\t%s\n',repmat('-',[1 maxChars]));
            else
                % single line
                neurostim.utils.cprintf(style,'TR: %d (T: %.0f %s): %s - %s \n',thisTrial,thisTrialTime,phaseStr,plg,msg);
            end
        end
        
        function checkToolbox(~)
            f = which('tcpip');
            if isempty(f)
                error('neurostim.messenger requires the tcpip command (part of the Instrument Control Toolbox). Install it to use messenger across the network (or set c.messenger.host =''''  to use local messaged only.');
            end
        end
        
    end
    
    
    
end